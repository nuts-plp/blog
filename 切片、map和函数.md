

## 切片（rune）

切片（slice）是一个有用相同类型元素可变长度的序列。它是基于数组类型做的一层封装。支持自动扩容

切片是一个引用数据类型，它的内容包括地址，长度，容量。切片一般用于快速的操作一块数据集合

### 引子

**由于数组的长度是固定的并且数组的长度是数组类型的一部分，所以数组有很多局限性**

1、数组只能接受定义时的数据类型

2、数组不能扩容

**切片的声明**

`var name [] T`

var是变量的声明，name是切片的名字,T表示切片的数据类型

**例：**

![image-20220602091021531](C:\Users\88463\Desktop\笔记\image-20220602091021531.png)

**切片的本质**

切片就是一个框，框住底层的数组数据

![image-20220602102101110](C:\Users\88463\Desktop\笔记\image-20220602102101110.png)

![image-20220602102119859](C:\Users\88463\Desktop\笔记\image-20220602102119859.png)

### 创建切片

 **make()函数创造**

`make([]T, size,cap)`    T为切片的数据类型，size为切片的长度，cap为切片的容量

`make([]T,size) `     此方法创建的切片默认长度与容量相同

![image-20220602104854378](C:\Users\88463\Desktop\笔记\image-20220602104854378.png)

**通过数组创造**

先创建一个数组，再通过数组得到切片

![image-20220602110251100](C:\Users\88463\Desktop\笔记\image-20220602110251100.png)

### 判断切片是否为空

要判断切片是否为空，请始终使用`len(slice_name) == 0`,而不是使用slice_name==nil,当slice_name==nil时指的是切片没有底层数组，此时切片的长度和容量都是0，而长度和容量都是0的切片不一定是一个nil切片

例：

![image-20220602102648744](C:\Users\88463\Desktop\笔记\image-20220602102648744.png)

所以，判断切片判断切片是否为空应用`len(slice_name) == 0`来判断

### 切片不能直接比较

切片是不能直接比较的，我们不能用==来比较两个切片的数据是否完全相同，go语言中也没有像其他语言一样的`equals()`函数去比较是否相同，唯一能比较的就是slice_name ==nil,判断一个切片是否是nil切片

### nil切片

![image-20220602103213935](C:\Users\88463\Desktop\笔记\image-20220602103213935.png)

### 空切片

![image-20220602103644720](C:\Users\88463\Desktop\笔记\image-20220602103644720.png)

### 切片的遍历

![image-20220602103755684](C:\Users\88463\Desktop\笔记\image-20220602103755684.png)

### 切片的赋值拷贝

**利用copy()函数实现拷贝**

`copy(slice_name1,slice_name2)`   slice_name1是拷贝数据的副本切片，slice_name2是源数据切片，**所使用的底层数组不是同一个**

![image-20220602131537594](C:\Users\88463\Desktop\笔记\image-20220602131537594.png)

切片的复制是共享底层数组的，改变其中一个切片影响另一个切片

![image-20220602112206313](C:\Users\88463\Desktop\笔记\image-20220602112206313.png)

打印结果

![image-20220602112313307](C:\Users\88463\Desktop\笔记\image-20220602112313307.png)

### append()函数扩容切片

`append(slice_name,element)`    为切片slice_name添加元素element

如果切片没有初始化，append()函数能够自动初始化切片

![image-20220602122451992](C:\Users\88463\Desktop\笔记\image-20220602122451992.png)



`append(slice_name1,slice_name2...) `  把切片`slice_name2`中的元素分别添加进`slice_name1`切片中...表示把切片拆成单个元素

![image-20220602122305332](C:\Users\88463\Desktop\笔记\image-20220602122305332.png)

当使用`append()`函数时，切片`slice_name1`的容量不足时，会按照一定规则重新创建一个底层数组，把原数组和新元素放进新数组中

![image-20220602123752984](C:\Users\88463\Desktop\笔记\image-20220602123752984.png)

**利用append()函数实现切片元素的删除**

利用`append()`函数删除元素时，使用的还是同一个底层数组，只是把后面数据前移了，所以切片的长度有变化，但容量无变化

![image-20220602124742141](C:\Users\88463\Desktop\笔记\image-20220602124742141.png)

**扩容规则**

![image-20220602122632799](C:\Users\88463\Desktop\笔记\image-20220602122632799.png)

### 重点：一段特殊的描述

创建一个长度小于容量的切片

![image-20220602170812991](C:\Users\88463\Desktop\笔记\image-20220602170812991.png)

此时的切片数据![image-20220602171050207](C:\Users\88463\Desktop\笔记\image-20220602171050207.png)

此时的切片内存地址为![image-20220602171027230](C:\Users\88463\Desktop\笔记\image-20220602171027230.png)

添加两个元素后

![image-20220602171121225](C:\Users\88463\Desktop\笔记\image-20220602171121225.png)



此时的切片数据为![image-20220602171150886](C:\Users\88463\Desktop\笔记\image-20220602171150886.png)

此时的切片内存地址为![image-20220602171215251](C:\Users\88463\Desktop\笔记\image-20220602171215251.png)

地址没有发生变化

当再次为该切片添加元素

![image-20220602171324533](C:\Users\88463\Desktop\笔记\image-20220602171324533.png)

此时的切片数据为![image-20220602171417923](C:\Users\88463\Desktop\笔记\image-20220602171417923.png)

此时的切片内存地址![image-20220602171519793](C:\Users\88463\Desktop\笔记\image-20220602171519793.png)

说明底层数组发生了变化，发生了扩容，指向了新数组

改变一个切片元素

![image-20220602171807845](C:\Users\88463\Desktop\笔记\image-20220602171807845.png)

此时的切片数据![image-20220602171834095](C:\Users\88463\Desktop\笔记\image-20220602171834095.png)

此时的切片内存地址![image-20220602171901361](C:\Users\88463\Desktop\笔记\image-20220602171901361.png)

**整体描述**

**append()函数添加元素**

![image-20220602174750480](C:\Users\88463\Desktop\笔记\image-20220602174750480.png)

## 指针

取地址`&`

根据地址取值`*`

![image-20220602135910755](C:\Users\88463\Desktop\笔记\image-20220602135910755.png)

![image-20220602134708861](C:\Users\88463\Desktop\笔记\image-20220602134708861.png)

**特别的**

![image-20220602135528112](C:\Users\88463\Desktop\笔记\image-20220602135528112.png)

### make()和new()的区别

​		**`make()`和`new()`都是内置函数且都是用来分配内存的**

对于引用数据类型的数据，我们不仅要声明他还要为他分配内存空间，引用数据类型有`slice、map、channel`等。`make()`主要为引用数据类型分配内存空间,**返回的是类型本身**

对于值数据类型，在声明时就已经为他开辟了内存空间了，值数据类型有`string、array、int`等。`new()`主要为值数据类型开辟内存，**返回的是指向类型的指针**







## map

map是一种引用数据类型



### map的声明和初始化

`var a  map [KeyType]ValueType`  a为变量名称，`KeyType`为键的数据类型，`ValueType`为值的数据类型

![image-20220602145215950](C:\Users\88463\Desktop\笔记\image-20220602145215950.png)

### map的make()函数创建

`map_name := make(map[KeyType]ValueType,count)`      `KeyType`和`ValueType`同上，count为map的长度

### map的元素添加

![image-20220602145301445](C:\Users\88463\Desktop\笔记\image-20220602145301445.png)

### map的取值

如果取不到值，返回0

![image-20220602194349789](C:\Users\88463\Desktop\笔记\image-20220602194349789.png)

### map的遍历



### delete()函数删除键值对

`delete(slice_name,key)`    slice_name是要删除元素的map，key是要删除元素的key值

如果不存在，不做任何操作

如果存在则删除





### map与slice的结合

![image-20220602180705273](C:\Users\88463\Desktop\笔记\image-20220602180705273.png)

![image-20220602180719325](C:\Users\88463\Desktop\笔记\image-20220602180719325.png)



![image-20220604091343475](C:\Users\88463\Desktop\笔记\image-20220604091343475.png)

![image-20220604091400736](C:\Users\88463\Desktop\笔记\image-20220604091400736.png)

## 函数

一种数据类型

### 函数的定义

![image-20220602161124952](C:\Users\88463\Desktop\笔记\image-20220602161124952.png)

### 匿名返回值的函数

![image-20220602161158015](C:\Users\88463\Desktop\笔记\image-20220602161158015.png)

### 隐式返回的函数

![image-20220602161215980](C:\Users\88463\Desktop\笔记\image-20220602161215980.png)

### 省略参数类型的函数

![image-20220602161238177](C:\Users\88463\Desktop\笔记\image-20220602161238177.png)

### 多个返回值的函数

![image-20220602161300188](C:\Users\88463\Desktop\笔记\image-20220602161300188.png)

### 没有返回值的函数

![image-20220602161342218](C:\Users\88463\Desktop\笔记\image-20220602161342218.png)

### 既没有返回值又没有参数的函数

![image-20220602161417814](C:\Users\88463\Desktop\笔记\image-20220602161417814.png)

### 可变长参数的函数

![image-20220602161500029](C:\Users\88463\Desktop\笔记\image-20220602161500029.png)

### 上述函数的调用及打印输出

![image-20220602161544267](C:\Users\88463\Desktop\笔记\image-20220602161544267.png)



### 匿名函数

#### 把匿名函数赋值给一个变量

![image-20220603125515632](C:\Users\88463\Desktop\笔记\image-20220603125515632.png)

#### 对于只使用一次的匿名函数

![image-20220603140911699](C:\Users\88463\Desktop\笔记\image-20220603140911699.png)

函数体后的括号表示调用，里面的值表示传进去的参数值

### 把无参函数作为参数的函数

![image-20220603130753434](C:\Users\88463\Desktop\笔记\image-20220603130753434.png)



### 把有参函数作为参数的函数

![image-20220603130812056](C:\Users\88463\Desktop\笔记\image-20220603130812056.png)

### 把无参函数作为返回值的函数

![image-20220603131937477](C:\Users\88463\Desktop\笔记\image-20220603131937477.png)

### 把有参函数作为返回值的函数

![image-20220603131953454](C:\Users\88463\Desktop\笔记\image-20220603131953454.png)

### 把有参函数作为参数把有参函数作为返回值的函数



![image-20220603134727893](C:\Users\88463\Desktop\笔记\image-20220603134727893.png)

### 上述函数的调用

![image-20220603134830122](C:\Users\88463\Desktop\笔记\image-20220603134830122.png)

